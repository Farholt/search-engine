{"ast":null,"code":"const sqlite3 = require('sqlite3');\n\nconst sqlite = require('sqlite');\n\nconst weightedCalculations = async a => {\n  let arr = []; // array for concat\n\n  /* wsum */\n\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < a[i].length; j++) {\n      arr.push(a[i][j]);\n    }\n  }\n\n  let result = arr.reduce((accumulator, cur) => {\n    let id = cur.movieId;\n    let found = accumulator.find(elem => {\n      return elem.movieId == id;\n    });\n    /* If we find duplicates we do the weighted calculations */\n\n    if (found) {\n      found.ws += cur.ws; // sum score\n\n      found.sim += cur.sim; // sum sim for movie\n\n      found.wsSim = found.ws / found.sim; // end recommendation score\n    }\n    /* ... else we just push the single into the accumulator */\n    else {\n        accumulator.push(cur);\n      }\n\n    return accumulator; // return to result\n  }, []);\n  /* sort wsSim descending order */\n\n  result.sort((a, b) => parseFloat(b.wsSim) - parseFloat(a.wsSim));\n  return result;\n};\n/**\r\n * Calculating weighted score\r\n * @param a \r\n */\n\n\nconst weightedScore = async (a, score) => {\n  let sim = score;\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) {\n    let wScore = a[i]['rating'] * score;\n    arr.push({\n      movieId: a[i]['movieId'],\n      title: a[i]['title'],\n      wScore: wScore,\n      ws: wScore,\n      sim: score,\n      wsSim: 0\n    });\n  }\n\n  return arr;\n};\n/**\r\n * Calculating euclidean score\r\n * @param a \r\n * @param b \r\n */\n\n\nconst euclideanUser = async (a, b) => {\n  let sim = 0; // integer\n\n  let n = 0; //  counter for number of matching products\n\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i]['movieId'] == b[j]['movieId']) {\n        sim += (a[i]['rating'] - b[j]['rating']) ** 2;\n        n += 1;\n      }\n    }\n  }\n\n  if (n == 0) {\n    return 0;\n  }\n\n  let inv = 1 / (1 + sim);\n  return inv; // return inv;\n};\n\nconst euclideanAPI = async (req, res) => {\n  const id = req.query.id; // main user\n\n  /* DB connection */\n\n  const db = await sqlite.open({\n    filename: './mydb.sqlite',\n    driver: sqlite3.Database\n  });\n  /* sql */\n\n  let user = await db.all('SELECT * FROM users where id = ?', [id]);\n  /* Retrieve ratings that belongs to main user */\n\n  let userRatings = await db.all('SELECT userId, movies.title, movieId, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [id]);\n  let otherUsers = await db.all('SELECT name, id FROM users where id != ?', [id]);\n  let userSimilarity = []; // adding euclidean result here\n\n  let x = []; // adding euclidean result here\n\n  let test = [\"2\", \"3\", \"4\", \"6\", \"7\", \"9\", \"11\", \"14\", \"15\", \"20\", \"24\", \"25\", \"27\", \"28\"];\n  /* Getting the similarity between users */\n\n  for (let i = 0; i < otherUsers.length; i++) {\n    let id = otherUsers[i]['id'];\n    let name = otherUsers[i]['name'];\n    /* Retrieve ratings for all the other users */\n\n    let otherUserRatings = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ? AND movieId NOT IN ?', [id, \"(2, 3, 4, 6, 7, 9, 11, 14, 15, 20, 24, 25, 27, 28)\"]);\n    let euclideanScore = await euclideanUser(userRatings, otherUserRatings); // get euclidean score\n\n    let wScore = await weightedScore(otherUserRatings, euclideanScore); // get weighter score\n\n    x.push({\n      weighted_scores: wScore\n    });\n    /* Push objects */\n\n    userSimilarity.push({\n      id: id,\n      user_name: name,\n      score: euclideanScore,\n      weighted_scores: wScore // high score = more similar\n\n    });\n  }\n  /* Push array with user objects */\n\n\n  user[0]['user_similarity'] = userSimilarity;\n  x = user.map(y => {\n    return y['user_similarity'].map(k => {\n      return k['weighted_scores'];\n    });\n  });\n  user = JSON.stringify(user, null, 2);\n  let test2 = await weightedCalculations(x[0]); // let test = JSON.stringify(x[0], null, 2);\n\n  let op = JSON.stringify(test2, null, 2); // let us = JSON.stringify(userSimilarity, null, 2);\n\n  res.json(op);\n};\n\nexport default euclideanAPI;","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A1/pages/api/euclidean/[id].ts"],"names":["sqlite3","require","sqlite","weightedCalculations","a","arr","i","length","j","push","result","reduce","accumulator","cur","id","movieId","found","find","elem","ws","sim","wsSim","sort","b","parseFloat","weightedScore","score","wScore","title","euclideanUser","n","inv","euclideanAPI","req","res","query","db","open","filename","driver","Database","user","all","userRatings","otherUsers","userSimilarity","x","test","name","otherUserRatings","euclideanScore","weighted_scores","user_name","map","y","k","JSON","stringify","test2","op","json"],"mappings":"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","sourcesContent":["import { Console } from 'console';\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\nconst sqlite3 = require('sqlite3');\r\nconst sqlite = require('sqlite');\r\n\r\nconst weightedCalculations = async (a: Array<any>) => {\r\n    \r\n    let arr: Array<any> = []; // array for concat\r\n\r\n    /* wsum */\r\n    for (let i: number = 0; i < a.length; i++) {\r\n        for (let j: number = 0; j < a[i].length; j++) {\r\n            arr.push(a[i][j]);\r\n        }\r\n    }\r\n\r\n    let result = arr.reduce((accumulator, cur) => {\r\n\r\n        let id = cur.movieId;\r\n        \r\n        let found: any = accumulator.find((elem: { movieId: any; }) => {\r\n            return elem.movieId == id;\r\n        })\r\n\r\n        /* If we find duplicates we do the weighted calculations */\r\n        if (found) {\r\n            found.ws += cur.ws; // sum score\r\n            found.sim += cur.sim; // sum sim for movie\r\n            found.wsSim = found.ws / found.sim; // end recommendation score\r\n        }\r\n        /* ... else we just push the single into the accumulator */\r\n        else {\r\n            accumulator.push(cur)\r\n        }\r\n        \r\n        return accumulator; // return to result\r\n\r\n    }, []);\r\n\r\n    /* sort wsSim descending order */\r\n    result.sort((a: { wsSim: any; }, b: { wsSim: any; }) =>\r\n        parseFloat(b.wsSim) - parseFloat(a.wsSim)\r\n    ); \r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Calculating weighted score\r\n * @param a \r\n */\r\nconst weightedScore = async (a: any, score: number) => {\r\n    \r\n    let sim: number = score; \r\n\r\n    let arr: Array<any> = [];\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n        let wScore: number = a[i]['rating'] * score;\r\n\r\n        arr.push({\r\n            movieId: a[i]['movieId'],\r\n            title: a[i]['title'],\r\n            wScore: wScore,\r\n            ws: wScore,\r\n            sim: score,\r\n            wsSim: 0\r\n        });\r\n\r\n    }\r\n\r\n    return arr;\r\n}\r\n \r\n/**\r\n * Calculating euclidean score\r\n * @param a \r\n * @param b \r\n */\r\nconst euclideanUser = async (a: any, b: any) => {\r\n    let sim: number = 0; // integer\r\n    let n: number = 0; //  counter for number of matching products\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n        for (let j = 0; j < b.length; j++) {\r\n            if (a[i]['movieId'] == b[j]['movieId']) {\r\n                sim += (a[i]['rating'] - b[j]['rating']) ** 2;\r\n                n += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (n == 0) {\r\n        return 0;\r\n    }\r\n\r\n    let inv: number = 1 / (1 + sim);\r\n\r\n    return inv;\r\n    // return inv;\r\n};\r\n\r\nconst euclideanAPI = async (req: NextApiRequest, res: NextApiResponse) => {\r\n    const id: any = req.query.id; // main user\r\n\r\n    /* DB connection */\r\n    const db = await sqlite.open({\r\n        filename: './mydb.sqlite',\r\n        driver: sqlite3.Database\r\n    });\r\n   \r\n    /* sql */\r\n    let user: any = await db.all('SELECT * FROM users where id = ?', [id]);\r\n    /* Retrieve ratings that belongs to main user */\r\n    let userRatings: any = await db.all('SELECT userId, movies.title, movieId, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [id]);\r\n    let otherUsers: any = await db.all('SELECT name, id FROM users where id != ?', [id]);\r\n\r\n    let userSimilarity: Array<any> = []; // adding euclidean result here\r\n    let x: Array<any> = []; // adding euclidean result here\r\n\r\n    let test = [\"2\", \"3\", \"4\", \"6\", \"7\", \"9\", \"11\", \"14\", \"15\", \"20\", \"24\", \"25\", \"27\", \"28\"];\r\n\r\n    /* Getting the similarity between users */\r\n    for (let i: number = 0; i < otherUsers.length; i++) {\r\n\r\n        let id: number = otherUsers[i]['id'];\r\n        let name: String = otherUsers[i]['name'];\r\n\r\n        /* Retrieve ratings for all the other users */\r\n        let otherUserRatings: any = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ? AND movieId NOT IN ?', [id, \"(2, 3, 4, 6, 7, 9, 11, 14, 15, 20, 24, 25, 27, 28)\"]);\r\n     \r\n        let euclideanScore: any = await euclideanUser(userRatings, otherUserRatings); // get euclidean score\r\n\r\n        let wScore: any = await weightedScore(otherUserRatings, euclideanScore); // get weighter score\r\n\r\n        x.push({weighted_scores: wScore});\r\n\r\n        /* Push objects */\r\n        userSimilarity.push({\r\n            id: id,\r\n            user_name: name,\r\n            score: euclideanScore,\r\n            weighted_scores: wScore // high score = more similar\r\n        });\r\n    }\r\n\r\n    /* Push array with user objects */\r\n    user[0]['user_similarity'] = userSimilarity;\r\n\r\n    x = user.map(y => {\r\n        return y['user_similarity'].map(k => {\r\n            return k['weighted_scores'];\r\n        });\r\n    })\r\n\r\n    user = JSON.stringify(user, null, 2);\r\n\r\n    let test2 = await weightedCalculations(x[0]);\r\n\r\n    // let test = JSON.stringify(x[0], null, 2);\r\n    let op = JSON.stringify(test2, null, 2);\r\n\r\n    // let us = JSON.stringify(userSimilarity, null, 2);\r\n    res.json(op);\r\n}\r\n\r\nexport default euclideanAPI;"]},"metadata":{},"sourceType":"module"}