{"ast":null,"code":"/**\r\n * @desc this function returns a frequency score\r\n * @param p takes scores.content\r\n * @param query is the search string\r\n */\nconst getFrequencyScore = (p, query) => {\n  let score = 0;\n  const querySplit = query.split(' '); // string into array\n\n  /* Get key for page object, e.g. 7400_series */\n\n  for (let key in p) {\n    /* Condition that retrieves page objects properties */\n    if (p.hasOwnProperty(key)) {\n      /* Loop through the word list for that page */\n      for (let i = 0; i < p[key].words.length; i++) {\n        let word = p[key].words[i][0];\n        let lc = word.toLowerCase();\n        /* If there is a match add 1 to score */\n\n        for (let j = 0; j < querySplit.length; j++) {\n          if (lc == querySplit[j]) {\n            score++;\n          }\n        }\n      }\n    }\n  }\n\n  return score;\n};\n/**\r\n * @desc this function returns a location score\r\n * @param p takes scores.location\r\n * @param query is the search string\r\n */\n\n\nconst getLocationScore = (p, query) => {\n  let score = 0;\n  const querySplit = query.split(' '); // string into array\n\n  for (let i = 0; i < querySplit.length; i++) {\n    let found = false;\n\n    for (let key in p) {\n      if (p.hasOwnProperty(key)) {\n        for (let j = 0; j < p[key].words.length; j++) {\n          let word = p[key].words[i][0];\n          let lc = word.toLowerCase();\n          let wordIndex = p[key].words[i][1];\n\n          if (lc == querySplit[i]) {\n            score += wordIndex + 1;\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (!found) score += 100000;\n  }\n\n  return score;\n};\n/**\r\n * @desc this function returns a distance score\r\n * @param p takes a scores object\r\n * @param query is the search string\r\n */\n\n\nconst getWordDistanceScore = (p, query) => {\n  let score = 0;\n  const querySplit = query.split(' '); // string into array\n\n  let locationScores = [];\n\n  for (let i = 0; i < querySplit.length; i++) {\n    let tmp = getLocationScore(p, querySplit[i]);\n    locationScores.push(tmp > 0 ? tmp : 100000);\n  }\n\n  for (let i = 0; i < locationScores.length; i++) {\n    for (let j = 1; j < locationScores.length; j++) {\n      if (locationScores[i] == 100000 || locationScores[j] == 100000) {\n        score += 100000;\n      } else {\n        score += Math.abs(locationScores[i] - locationScores[j]);\n      }\n\n      break;\n    }\n\n    break;\n  }\n\n  return score;\n};\n/**\r\n * @desc this function returns a normalization score\r\n * @param p takes a score array\r\n * @param smallIsBetter decides the normalization\r\n */\n\n\nconst normalize = (scores, smallIsBetter) => {\n  if (smallIsBetter) {\n    let min = Math.min(...scores);\n\n    for (let i = 0; i < scores.length; i++) scores[i] = min / Math.max(scores[i], 0.00001);\n  } else {\n    let max = Math.max(...scores);\n    max = Math.max(max, 0.00001);\n\n    for (let i = 0; i < scores.length; i++) scores[i] = scores[i] / max;\n  }\n\n  return scores;\n};\n\nconst search = (req, res) => {\n  // const query: any = req.body.query\n  const query = 'super mario';\n\n  const fs = require('fs');\n\n  const str = fs.readFileSync('shared/json/pages.json').toString();\n  let obj = JSON.parse(str);\n  let result = [];\n  let scores = {\n    content: [],\n    location: [],\n    distance: []\n  };\n\n  for (let i = 0; i < obj.length; i++) {\n    let p = obj[i]; // this is the page object\n\n    /* Here comes the frequence metric function */\n\n    scores.content[i] = getFrequencyScore(p, query);\n    scores.location[i] = getLocationScore(p, query);\n    scores.distance[i] = getWordDistanceScore(p, query);\n  }\n  /* Here comes the normalization of the scores */\n\n\n  normalize(scores.content, false);\n  normalize(scores.location, true);\n  normalize(scores.distance, true);\n  let score; // end score\n\n  for (let i = 0; i < obj.length; i++) {\n    let p = obj[i];\n    score = scores.content[i] + 0.8 * scores.location[i];\n    /* Get key for page object, e.g. 7400_series */\n\n    for (let key in p) {\n      /* Condition that retrieves page objects properties */\n      if (p.hasOwnProperty(key)) {\n        result.push({\n          link: key,\n          score: Math.round((score + Number.EPSILON) * 100) / 100,\n          content: Math.round((scores.content[i] + Number.EPSILON) * 100) / 100,\n          location: Math.round((0.8 * scores.location[i] + Number.EPSILON) * 100) / 100,\n          distance: Math.round((scores.distance[i] + Number.EPSILON) * 100) / 100,\n          pagerank: 0\n        });\n      }\n    }\n  }\n\n  result.sort((a, b) => parseFloat(b.score) - parseFloat(a.score));\n  res.json(JSON.stringify(result.slice(0, 8), null, 2));\n};\n\nexport default search;","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A3/pages/api/search.ts"],"names":["getFrequencyScore","p","query","score","querySplit","split","key","hasOwnProperty","i","words","length","word","lc","toLowerCase","j","getLocationScore","found","wordIndex","getWordDistanceScore","locationScores","tmp","push","Math","abs","normalize","scores","smallIsBetter","min","max","search","req","res","fs","require","str","readFileSync","toString","obj","JSON","parse","result","content","location","distance","link","round","Number","EPSILON","pagerank","sort","a","b","parseFloat","json","stringify","slice"],"mappings":"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","sourcesContent":["import { strict } from 'assert'\r\nimport { forEach } from 'list'\r\nimport { NextApiRequest, NextApiResponse } from 'next'\r\n\r\n/**\r\n * @desc this function returns a frequency score\r\n * @param p takes scores.content\r\n * @param query is the search string\r\n */\r\nconst getFrequencyScore = (p: object, query: string): number => {\r\n  let score: number = 0\r\n  const querySplit: Array<string> = query.split(' ') // string into array\r\n\r\n  /* Get key for page object, e.g. 7400_series */\r\n  for (let key in p) {\r\n    /* Condition that retrieves page objects properties */\r\n    if (p.hasOwnProperty(key)) {\r\n      /* Loop through the word list for that page */\r\n      for (let i = 0; i < p[key].words.length; i++) {\r\n        let word: string = p[key].words[i][0]\r\n        let lc: string = word.toLowerCase()\r\n        /* If there is a match add 1 to score */\r\n        for (let j = 0; j < querySplit.length; j++) {\r\n          if (lc == querySplit[j]) {\r\n            score++\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return score\r\n}\r\n\r\n/**\r\n * @desc this function returns a location score\r\n * @param p takes scores.location\r\n * @param query is the search string\r\n */\r\nconst getLocationScore = (p: object, query: string): number => {\r\n  let score: number = 0\r\n  const querySplit: Array<string> = query.split(' ') // string into array\r\n\r\n  for (let i = 0; i < querySplit.length; i++) {\r\n    let found: boolean = false\r\n    for (let key in p) {\r\n      if (p.hasOwnProperty(key)) {\r\n        for (let j = 0; j < p[key].words.length; j++) {\r\n          let word = p[key].words[i][0]\r\n          let lc: string = word.toLowerCase()\r\n          let wordIndex = p[key].words[i][1]\r\n          if (lc == querySplit[i]) {\r\n            score += wordIndex + 1\r\n            found = true\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!found) score += 100000\r\n  }\r\n\r\n  return score\r\n}\r\n\r\n/**\r\n * @desc this function returns a distance score\r\n * @param p takes a scores object\r\n * @param query is the search string\r\n */\r\nconst getWordDistanceScore = (p: object, query: string): any => {\r\n  let score: number = 0\r\n  const querySplit: Array<string> = query.split(' ') // string into array\r\n  let locationScores = []\r\n\r\n  for (let i = 0; i < querySplit.length; i++) {\r\n    let tmp = getLocationScore(p, querySplit[i])\r\n    locationScores.push(tmp > 0 ? tmp : 100000)\r\n  }\r\n\r\n  for (let i = 0; i < locationScores.length; i++) {\r\n    for (let j = 1; j < locationScores.length; j++) {\r\n      if (locationScores[i] == 100000 || locationScores[j] == 100000) {\r\n        score += 100000\r\n      } else {\r\n        score += Math.abs(locationScores[i] - locationScores[j])\r\n      }\r\n      break\r\n    }\r\n    break\r\n  }\r\n\r\n  return score\r\n}\r\n\r\n/**\r\n * @desc this function returns a normalization score\r\n * @param p takes a score array\r\n * @param smallIsBetter decides the normalization\r\n */\r\nconst normalize = (\r\n  scores: Array<number>,\r\n  smallIsBetter: boolean\r\n): Array<number> => {\r\n  if (smallIsBetter) {\r\n    let min: number = Math.min(...scores)\r\n    for (let i = 0; i < scores.length; i++)\r\n      scores[i] = min / Math.max(scores[i], 0.00001)\r\n  } else {\r\n    let max: number = Math.max(...scores)\r\n    max = Math.max(max, 0.00001)\r\n    for (let i = 0; i < scores.length; i++) scores[i] = scores[i] / max\r\n  }\r\n\r\n  return scores\r\n}\r\n\r\nconst search = (req: NextApiRequest, res: NextApiResponse) => {\r\n  // const query: any = req.body.query\r\n  const query: string = 'super mario'\r\n\r\n  const fs = require('fs')\r\n  const str: string = fs.readFileSync('shared/json/pages.json').toString()\r\n  let obj: Array<object> = JSON.parse(str)\r\n\r\n  let result = []\r\n  let scores = { content: [], location: [], distance: [] }\r\n\r\n  for (let i = 0; i < obj.length; i++) {\r\n    let p = obj[i] // this is the page object\r\n\r\n    /* Here comes the frequence metric function */\r\n    scores.content[i] = getFrequencyScore(p, query)\r\n    scores.location[i] = getLocationScore(p, query)\r\n    scores.distance[i] = getWordDistanceScore(p, query)\r\n  }\r\n\r\n  /* Here comes the normalization of the scores */\r\n  normalize(scores.content, false)\r\n  normalize(scores.location, true)\r\n  normalize(scores.distance, true)\r\n\r\n  let score: number // end score\r\n\r\n  for (let i = 0; i < obj.length; i++) {\r\n    let p = obj[i]\r\n\r\n    score = scores.content[i] + 0.8 * scores.location[i]\r\n\r\n    /* Get key for page object, e.g. 7400_series */\r\n    for (let key in p) {\r\n      /* Condition that retrieves page objects properties */\r\n      if (p.hasOwnProperty(key)) {\r\n        result.push({\r\n          link: key,\r\n          score: Math.round((score + Number.EPSILON) * 100) / 100,\r\n          content: Math.round((scores.content[i] + Number.EPSILON) * 100) / 100,\r\n          location:\r\n            Math.round((0.8 * scores.location[i] + Number.EPSILON) * 100) / 100,\r\n          distance:\r\n            Math.round((scores.distance[i] + Number.EPSILON) * 100) / 100,\r\n          pagerank: 0\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  result.sort((a, b) => parseFloat(b.score) - parseFloat(a.score))\r\n\r\n  res.json(JSON.stringify(result.slice(0, 8), null, 2))\r\n}\r\n\r\nexport default search\r\n"]},"metadata":{},"sourceType":"module"}