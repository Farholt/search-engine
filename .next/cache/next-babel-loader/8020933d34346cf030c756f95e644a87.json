{"ast":null,"code":"const getFrequencyScore = (p, query) => {\n  let score = 0;\n  /* Get key for page object, e.g. 7400_series */\n\n  for (let key in p) {\n    /* Condition that retrieves page objects properties */\n    if (p.hasOwnProperty(key)) {\n      /* Loop through the word list for that page */\n      for (let i = 0; i < p[key].words.length; i++) {\n        /* If there is a match add 1 to score */\n        if (p[key].words[i][0] == query) {\n          score++;\n        }\n      }\n    }\n  }\n\n  return score;\n};\n/**\r\n * @desc this function returns a location score\r\n * @param p takes scores.location\r\n * @param query is the search string\r\n */\n\n\nconst getLocationScore = (p, query) => {\n  let score = 0;\n  /* Get key for page object, e.g. 7400_series */\n\n  for (let key in p) {\n    /* Condition that retrieves page objects properties */\n    if (p.hasOwnProperty(key)) {\n      /* Loop through the word list for that page */\n      for (let i = 0; i < p[key].words.length; i++) {\n        /* If there is a match add index to score */\n        if (p[key].words[i][0] == query) {\n          score = p[key].words[i][1]; // index of word in word list\n        }\n      }\n    }\n  }\n\n  return score;\n};\n\nconst getWordDistanceScore = (p, query) => {\n  let score = 0;\n  return score;\n};\n\nconst normalize = (scores, smallIsBetter) => {\n  if (smallIsBetter) {\n    let min = Math.min(...scores);\n\n    for (let i = 0; i < scores.length; i++) scores[i] = min / Math.max(...scores, 0.00001);\n  } else {\n    let max = Math.max(...scores);\n\n    for (let i = 0; i < scores.length; i++) scores[i] = scores[i] / max;\n  }\n\n  return scores;\n};\n\nconst findUniquePair = queryArray => {\n  let arr = [];\n\n  for (let i = 1; i < queryArray.length; i++) {}\n\n  return null;\n};\n\nconst search = (req, res) => {\n  // const query: any = req.body.query\n  const query = 'nintendo';\n  const querySplit = query.split(' '); // string into array\n\n  const queryList = new Map();\n\n  const getIdForWord = word => {\n    if (queryList.has(word)) {\n      return queryList.get('word');\n    } else {\n      let id = queryList.size;\n      queryList.set(word, id);\n      return id;\n    }\n  };\n\n  querySplit.forEach((key, index) => {\n    getIdForWord(key);\n  });\n\n  const fs = require('fs');\n\n  const str = fs.readFileSync('shared/json/pages.json').toString();\n  let obj = JSON.parse(str);\n  let result = [];\n  let scores = {\n    content: [],\n    location: []\n  };\n\n  for (let i = 0; i < obj.length; i++) {\n    let p = obj[i]; // this is the page object\n\n    /* Here comes the frequence metric function */\n\n    scores.content[i] = getFrequencyScore(p, query);\n    scores.location[i] = getLocationScore(p, query);\n  }\n  /* Here comes the normalization of the scores */\n\n\n  normalize(scores.content, false);\n  normalize(scores.location, true);\n  let score; // end score\n\n  for (let i = 0; i < obj.length; i++) {\n    let p = obj[i];\n    score = 1.0 * scores.content[i] + 0.5 * scores.location[i];\n    /* Get key for page object, e.g. 7400_series */\n\n    for (let key in p) {\n      /* Condition that retrieves page objects properties */\n      if (p.hasOwnProperty(key)) {\n        result.push({\n          key: {\n            score: score,\n            content: scores.content[i],\n            location: scores.location[i],\n            pagerank: 0\n          }\n        });\n      }\n    }\n  }\n\n  res.json(JSON.stringify(result, null, 2));\n};\n\nexport default search;","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A3/pages/api/search.ts"],"names":["getFrequencyScore","p","query","score","key","hasOwnProperty","i","words","length","getLocationScore","getWordDistanceScore","normalize","scores","smallIsBetter","min","Math","max","findUniquePair","queryArray","arr","search","req","res","querySplit","split","queryList","Map","getIdForWord","word","has","get","id","size","set","forEach","index","fs","require","str","readFileSync","toString","obj","JSON","parse","result","content","location","push","pagerank","json","stringify"],"mappings":"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","sourcesContent":["import { strict } from 'assert'\r\nimport { forEach } from 'list'\r\nimport { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nconst getFrequencyScore = (p: object, query: string): number => {\r\n  let score: number = 0\r\n\r\n  /* Get key for page object, e.g. 7400_series */\r\n  for (let key in p) {\r\n    /* Condition that retrieves page objects properties */\r\n    if (p.hasOwnProperty(key)) {\r\n      /* Loop through the word list for that page */\r\n      for (let i = 0; i < p[key].words.length; i++) {\r\n        /* If there is a match add 1 to score */\r\n        if (p[key].words[i][0] == query) {\r\n          score++\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return score\r\n}\r\n\r\n/**\r\n * @desc this function returns a location score\r\n * @param p takes scores.location\r\n * @param query is the search string\r\n */\r\nconst getLocationScore = (p: object, query: string): number => {\r\n  let score: number = 0\r\n\r\n  /* Get key for page object, e.g. 7400_series */\r\n  for (let key in p) {\r\n    /* Condition that retrieves page objects properties */\r\n    if (p.hasOwnProperty(key)) {\r\n      /* Loop through the word list for that page */\r\n      for (let i = 0; i < p[key].words.length; i++) {\r\n        /* If there is a match add index to score */\r\n        if (p[key].words[i][0] == query) {\r\n          score = p[key].words[i][1] // index of word in word list\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return score\r\n}\r\n\r\nconst getWordDistanceScore = (p: object, query: Array<string>): number => {\r\n  let score: number = 0\r\n\r\n  return score\r\n}\r\n\r\nconst normalize = (\r\n  scores: Array<number>,\r\n  smallIsBetter: boolean\r\n): Array<number> => {\r\n  if (smallIsBetter) {\r\n    let min: number = Math.min(...scores)\r\n    for (let i = 0; i < scores.length; i++)\r\n      scores[i] = min / Math.max(...scores, 0.00001)\r\n  } else {\r\n    let max: number = Math.max(...scores)\r\n    for (let i = 0; i < scores.length; i++) scores[i] = scores[i] / max\r\n  }\r\n\r\n  return scores\r\n}\r\n\r\nconst findUniquePair = (queryArray: Array<string>): Array<string> => {\r\n  let arr = []\r\n\r\n  for (let i = 1; i < queryArray.length; i++) {}\r\n\r\n  return null\r\n}\r\n\r\nconst search = (req: NextApiRequest, res: NextApiResponse) => {\r\n  // const query: any = req.body.query\r\n  const query: string = 'nintendo'\r\n  const querySplit: Array<string> = query.split(' ') // string into array\r\n  const queryList = new Map()\r\n\r\n  const getIdForWord = (word: string) => {\r\n    if (queryList.has(word)) {\r\n      return queryList.get('word')\r\n    } else {\r\n      let id = queryList.size\r\n      queryList.set(word, id)\r\n      return id\r\n    }\r\n  }\r\n\r\n  querySplit.forEach((key, index) => {\r\n    getIdForWord(key)\r\n  })\r\n\r\n  const fs = require('fs')\r\n  const str: string = fs.readFileSync('shared/json/pages.json').toString()\r\n  let obj: Array<object> = JSON.parse(str)\r\n\r\n  let result = []\r\n  let scores = { content: [], location: [] }\r\n\r\n  for (let i = 0; i < obj.length; i++) {\r\n    let p = obj[i] // this is the page object\r\n\r\n    /* Here comes the frequence metric function */\r\n    scores.content[i] = getFrequencyScore(p, query)\r\n    scores.location[i] = getLocationScore(p, query)\r\n  }\r\n\r\n  /* Here comes the normalization of the scores */\r\n  normalize(scores.content, false)\r\n  normalize(scores.location, true)\r\n\r\n  let score: number // end score\r\n\r\n  for (let i = 0; i < obj.length; i++) {\r\n    let p = obj[i]\r\n\r\n    score = 1.0 * scores.content[i] + 0.5 * scores.location[i]\r\n\r\n    /* Get key for page object, e.g. 7400_series */\r\n    for (let key in p) {\r\n      /* Condition that retrieves page objects properties */\r\n      if (p.hasOwnProperty(key)) {\r\n        result.push({\r\n          key: {\r\n            score: score,\r\n            content: scores.content[i],\r\n            location: scores.location[i],\r\n            pagerank: 0\r\n          }\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  res.json(JSON.stringify(result, null, 2))\r\n}\r\n\r\nexport default search\r\n"]},"metadata":{},"sourceType":"module"}