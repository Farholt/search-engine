{"ast":null,"code":"const getUser = require('../../../getUser.js');\n\nconst sqlite3 = require('sqlite3');\n\nconst sqlite = require('sqlite');\n\nconst buildJson = async (user, eUserMatch, eMovieRecommends, pCUserMatch, pCMovieRecommends) => {\n  user[0]['top_matching_users'] = [];\n  user[0]['top_matching_users'].push({\n    euclidean: []\n  });\n  user[0]['top_matching_users'][0]['euclidean'] = eUserMatch;\n  user[0]['top_matching_users'].push({\n    pearson_correlation: []\n  });\n  user[0]['top_matching_users'][1]['pearson_correlation'] = pCUserMatch;\n  user[0]['recommended_movies'] = [];\n  user[0]['recommended_movies'].push({\n    euclidean: []\n  });\n  user[0]['recommended_movies'][0]['euclidean'] = eMovieRecommends.map(x => {\n    return {\n      title: x['title'],\n      id: x['movieId'],\n      score: x['wsSim']\n    };\n  });\n  user[0]['recommended_movies'].push({\n    pearson_correlation: []\n  });\n  user[0]['recommended_movies'][1]['pearson_correlation'] = pCMovieRecommends.map(x => {\n    return {\n      title: x['title'],\n      id: x['movieId'],\n      score: x['wsSim']\n    };\n  });\n  return user;\n};\n/**\r\n * All user ratings in an array with respective weighted values. Then try to find the duplicates and add the scores \r\n * @param a \r\n */\n\n\nconst weightedCalculations = async a => {\n  let arr = []; // array for concat\n\n  /* wsum */\n\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < a[i].length; j++) {\n      arr.push(a[i][j]);\n    }\n  }\n\n  let result = arr.reduce((accumulator, cur) => {\n    let id = cur.movieId;\n    let found = accumulator.find(elem => {\n      return elem.movieId == id;\n    });\n    /* If we find duplicates we do the weighted calculations */\n\n    if (found) {\n      found.ws += cur.ws; // sum score\n\n      found.sim += cur.sim; // sum sim for movie\n\n      found.wsSim = found.ws / found.sim; // end recommendation score\n    }\n    /* ... else we just push the single into the accumulator */\n    else {\n        cur.wsSim = cur.ws / cur.sim; // still need to calculate end score if only one is found\n\n        accumulator.push(cur);\n      }\n\n    return accumulator; // return to result\n  }, []);\n  /* sort wsSim (end score) descending order */\n\n  result.sort((a, b) => parseFloat(b.wsSim) - parseFloat(a.wsSim));\n  return result;\n};\n/**\r\n * Calculating weighted score\r\n * @param a \r\n */\n\n\nconst weightedScore = async (a, sim) => {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) {\n    let wScore = a[i]['rating'] * sim;\n    arr.push({\n      movieId: a[i]['movieId'],\n      title: a[i]['title'],\n      rating: a[i]['rating'],\n      wScore: wScore,\n      ws: wScore,\n      sim: sim,\n      wsSim: 0\n    });\n  }\n\n  return arr;\n};\n/**\r\n * Calculating euclidean score\r\n * @param a \r\n * @param b \r\n */\n\n\nconst euclideanUser = async (a, b) => {\n  let sim = 0; // integer\n\n  let n = 0; //  counter for number of matching products\n\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i]['movieId'] == b[j]['movieId']) {\n        sim += (a[i]['rating'] - b[j]['rating']) ** 2;\n        n += 1;\n      }\n    }\n  }\n\n  if (n == 0) {\n    return 0;\n  }\n\n  let inv = 1 / (1 + sim);\n  return inv;\n};\n\nconst pearsonCorrelation = async (a, b) => {\n  let sum1 = 0,\n      sum2 = 0,\n      sum1sq = 0,\n      sum2sq = 0,\n      pSum = 0,\n      n = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i]['movieId'] == b[j]['movieId']) {\n        sum1 += a[i]['rating'];\n        sum2 += b[j]['rating'];\n        sum1sq += a[i]['rating'] ** 2;\n        sum2sq += b[j]['rating'] ** 2;\n        pSum += a[i]['rating'] * b[j]['rating'];\n        n += 1;\n      }\n    }\n  }\n\n  if (n == 0) {\n    return 0;\n  }\n\n  let num = pSum - sum1 * sum2 / n;\n  let den = Math.sqrt((sum1sq - sum1 ** 2 / n) * (sum2sq - sum2 ** 2 / n));\n  return num / den;\n};\n\nconst euclideanAPI = async (req, res) => {\n  const id = req.query.id; // main user\n\n  /* DB connection */\n\n  const db = await sqlite.open({\n    filename: './mydb.sqlite',\n    driver: sqlite3.Database\n  });\n  /* sql */\n\n  let user = await db.all('SELECT * FROM users where id = ?', [id]);\n  /* Retrieve ratings that belongs to main user */\n\n  let userRatings = await db.all('SELECT userId, movies.title, movieId, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [id]);\n  /* All other users */\n\n  let otherUsers = await db.all('SELECT name, id FROM users where id != ?', [id]);\n  let eUserSimilarity = []; // adding euclidean result here\n\n  let eWScores = [];\n  let pCUserSimilarity = []; // adding pearson correlation result here\n\n  let pcWScores = [];\n  /* Getting the similarity between users */\n\n  for (let i = 0; i < otherUsers.length; i++) {\n    let subId = otherUsers[i]['id'];\n    let name = otherUsers[i]['name'];\n    /* Retrieve ratings for all the other users */\n\n    let otherUserRatings = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [subId]);\n    let euclideanScore = await euclideanUser(userRatings, otherUserRatings); // get euclidean score\n\n    let pCScore = await pearsonCorrelation(userRatings, otherUserRatings); // get euclidean score\n\n    /* Retrieve ratings for all the other users again, but now without the movies that main user has rated */\n\n    let otherUserRatings2 = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ? AND movieId NOT IN (SELECT ratings.movieId FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?)', [subId, id]);\n    /* Euclidean */\n\n    let eWScore = await weightedScore(otherUserRatings2, euclideanScore); // get weighter score\n\n    eWScores.push({\n      weighted_scores: eWScore\n    });\n    /* Push objects */\n\n    eUserSimilarity.push({\n      id: subId,\n      user_name: name,\n      euclideanScore: euclideanScore\n    });\n    /* Pearson Correlation above 0 */\n\n    if (pCScore > 0) {\n      let pcWScore = await weightedScore(otherUserRatings2, pCScore); // get weighter score\n\n      pcWScores.push({\n        weighted_scores: pcWScore\n      });\n      /* Push objects */\n\n      pCUserSimilarity.push({\n        id: subId,\n        user_name: name,\n        pearsonScore: pCScore\n      });\n    }\n  }\n  /* Sort similarity highest to lowest */\n\n  /* Euclidean */\n\n\n  eUserSimilarity.sort((a, b) => parseFloat(b.euclideanScore) - parseFloat(a.euclideanScore)); // /* Pearson Correlation */\n\n  pCUserSimilarity.sort((a, b) => parseFloat(b.pearsonScore) - parseFloat(a.pearsonScore));\n  let eWCalc = await weightedCalculations(eWScores.map(x => x['weighted_scores']));\n  let pCWCalc = await weightedCalculations(pcWScores.map(y => y['weighted_scores'])); // res.json(JSON.stringify(await buildJson(user, eUserSimilarity, eWCalc, pCUserSimilarity, pCWCalc), null, 2));\n\n  let test = await getUser(id);\n  res.json(test);\n};\n\nexport default euclideanAPI;","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A1/pages/api/euclidean/[id].ts"],"names":["getUser","require","sqlite3","sqlite","buildJson","user","eUserMatch","eMovieRecommends","pCUserMatch","pCMovieRecommends","push","euclidean","pearson_correlation","map","x","title","id","score","weightedCalculations","a","arr","i","length","j","result","reduce","accumulator","cur","movieId","found","find","elem","ws","sim","wsSim","sort","b","parseFloat","weightedScore","wScore","rating","euclideanUser","n","inv","pearsonCorrelation","sum1","sum2","sum1sq","sum2sq","pSum","num","den","Math","sqrt","euclideanAPI","req","res","query","db","open","filename","driver","Database","all","userRatings","otherUsers","eUserSimilarity","eWScores","pCUserSimilarity","pcWScores","subId","name","otherUserRatings","euclideanScore","pCScore","otherUserRatings2","eWScore","weighted_scores","user_name","pcWScore","pearsonScore","eWCalc","pCWCalc","y","test","json"],"mappings":"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","sourcesContent":["import { Console } from 'console';\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\n\r\nconst getUser =  require('../../../getUser.js');\r\n\r\nconst sqlite3 = require('sqlite3');\r\nconst sqlite = require('sqlite');\r\n\r\nconst buildJson = async (user: Array<any>, eUserMatch: Array<any>, eMovieRecommends: Array<any>, pCUserMatch: Array<any>, pCMovieRecommends: Array<any>) => {\r\n\r\n    user[0]['top_matching_users'] = [];\r\n    user[0]['top_matching_users'].push({ euclidean: [] });\r\n    user[0]['top_matching_users'][0]['euclidean'] = eUserMatch;\r\n    user[0]['top_matching_users'].push({ pearson_correlation: [] });\r\n    user[0]['top_matching_users'][1]['pearson_correlation'] = pCUserMatch;\r\n\r\n    user[0]['recommended_movies'] = [];\r\n    user[0]['recommended_movies'].push({ euclidean: [] });\r\n    user[0]['recommended_movies'][0]['euclidean'] = eMovieRecommends.map(x => {\r\n        return { title: x['title'], id: x['movieId'], score: x['wsSim'] }\r\n    });\r\n\r\n    user[0]['recommended_movies'].push({ pearson_correlation: [] });\r\n    user[0]['recommended_movies'][1]['pearson_correlation'] = pCMovieRecommends.map(x => {\r\n        return { title: x['title'], id: x['movieId'], score: x['wsSim'] }\r\n    });\r\n\r\n    return user;\r\n}\r\n\r\n/**\r\n * All user ratings in an array with respective weighted values. Then try to find the duplicates and add the scores \r\n * @param a \r\n */\r\nconst weightedCalculations = async (a: Array<any>) => {\r\n    \r\n    let arr: Array<any> = []; // array for concat\r\n\r\n    /* wsum */\r\n    for (let i: number = 0; i < a.length; i++) {\r\n        for (let j: number = 0; j < a[i].length; j++) {\r\n            arr.push(a[i][j]);\r\n        }\r\n    }\r\n\r\n    let result = arr.reduce((accumulator, cur) => {\r\n\r\n        let id = cur.movieId;\r\n        \r\n        let found: any = accumulator.find((elem: { movieId: any; }) => {\r\n            return elem.movieId == id;\r\n        })\r\n\r\n        /* If we find duplicates we do the weighted calculations */\r\n        if (found) {\r\n            found.ws += cur.ws; // sum score\r\n            found.sim += cur.sim; // sum sim for movie\r\n            found.wsSim = found.ws / found.sim; // end recommendation score\r\n        }\r\n        /* ... else we just push the single into the accumulator */\r\n        else {\r\n            cur.wsSim = cur.ws / cur.sim; // still need to calculate end score if only one is found\r\n            accumulator.push(cur)\r\n        }\r\n        \r\n        return accumulator; // return to result\r\n\r\n    }, []);\r\n\r\n    /* sort wsSim (end score) descending order */\r\n    result.sort((a: { wsSim: any; }, b: { wsSim: any; }) =>\r\n        parseFloat(b.wsSim) - parseFloat(a.wsSim)\r\n    ); \r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Calculating weighted score\r\n * @param a \r\n */\r\nconst weightedScore = async (a: any, sim: number) => {\r\n    let arr: Array<any> = [];\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n        let wScore: number = a[i]['rating'] * sim;\r\n\r\n        arr.push({\r\n            movieId: a[i]['movieId'],\r\n            title: a[i]['title'],\r\n            rating: a[i]['rating'],\r\n            wScore: wScore,\r\n            ws: wScore,\r\n            sim: sim,\r\n            wsSim: 0\r\n        });\r\n\r\n    }\r\n\r\n    return arr;\r\n}\r\n \r\n/**\r\n * Calculating euclidean score\r\n * @param a \r\n * @param b \r\n */\r\nconst euclideanUser = async (a: any, b: any) => {\r\n    let sim: number = 0; // integer\r\n    let n: number = 0; //  counter for number of matching products\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n        for (let j = 0; j < b.length; j++) {\r\n            if (a[i]['movieId'] == b[j]['movieId']) {\r\n                sim += (a[i]['rating'] - b[j]['rating']) ** 2;\r\n                n += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (n == 0) {\r\n        return 0;\r\n    }\r\n\r\n    let inv: number = 1 / (1 + sim);\r\n\r\n    return inv;\r\n};\r\n\r\nconst pearsonCorrelation = async (a: any, b: any) => {\r\n    let sum1 = 0,\r\n        sum2 = 0,\r\n        sum1sq = 0,\r\n        sum2sq = 0,\r\n        pSum = 0,\r\n        n = 0\r\n    \r\n    for (let i = 0; i < a.length; i++) {\r\n        for (let j = 0; j < b.length; j++) {\r\n\r\n            if (a[i]['movieId'] == b[j]['movieId']) {\r\n                sum1 += a[i]['rating']\r\n                sum2 += b[j]['rating']\r\n\r\n                sum1sq += a[i]['rating'] ** 2\r\n                sum2sq += b[j]['rating'] ** 2\r\n\r\n                pSum += a[i]['rating'] * b[j]['rating']\r\n\r\n                n += 1\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    if (n == 0) {\r\n        return 0\r\n    }\r\n\r\n    let num = pSum - (sum1 * sum2 / n)\r\n    let den = Math.sqrt((sum1sq - sum1 ** 2 / n) * (sum2sq - sum2 ** 2 / n))\r\n\r\n    return num/den;\r\n}\r\n\r\nconst euclideanAPI = async (req: NextApiRequest, res: NextApiResponse) => {\r\n    const id: any = req.query.id; // main user\r\n\r\n    /* DB connection */\r\n    const db = await sqlite.open({\r\n        filename: './mydb.sqlite',\r\n        driver: sqlite3.Database\r\n    });\r\n   \r\n    /* sql */\r\n    let user: any = await db.all('SELECT * FROM users where id = ?', [id]);\r\n    /* Retrieve ratings that belongs to main user */\r\n    let userRatings: any = await db.all('SELECT userId, movies.title, movieId, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [id]);\r\n\r\n    /* All other users */\r\n    let otherUsers: any = await db.all('SELECT name, id FROM users where id != ?', [id]);\r\n\r\n    let eUserSimilarity: Array<any> = []; // adding euclidean result here\r\n    let eWScores: Array<any> = [];\r\n\r\n    let pCUserSimilarity: Array<any> = []; // adding pearson correlation result here\r\n    let pcWScores: Array<any> = [];\r\n\r\n    /* Getting the similarity between users */\r\n    for (let i: number = 0; i < otherUsers.length; i++) {\r\n\r\n        let subId: number = otherUsers[i]['id'];\r\n        let name: String = otherUsers[i]['name'];\r\n\r\n        /* Retrieve ratings for all the other users */\r\n        let otherUserRatings: any = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?', [subId]);\r\n\r\n        let euclideanScore: any = await euclideanUser(userRatings, otherUserRatings); // get euclidean score\r\n        let pCScore: any = await pearsonCorrelation(userRatings, otherUserRatings); // get euclidean score\r\n\r\n        /* Retrieve ratings for all the other users again, but now without the movies that main user has rated */\r\n        let otherUserRatings2: any = await db.all('SELECT ratings.movieId, title, ratings.rating FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ? AND movieId NOT IN (SELECT ratings.movieId FROM ratings, users, movies WHERE users.id = userId AND movies.id = movieId AND users.id = ?)', [subId, id]);\r\n            \r\n        /* Euclidean */\r\n        let eWScore: any = await weightedScore(otherUserRatings2, euclideanScore); // get weighter score\r\n        eWScores.push({weighted_scores: eWScore});\r\n    \r\n        /* Push objects */\r\n        eUserSimilarity.push({\r\n            id: subId,\r\n            user_name: name,\r\n            euclideanScore: euclideanScore,\r\n        });  \r\n\r\n        /* Pearson Correlation above 0 */\r\n        if (pCScore > 0) {\r\n            let pcWScore: any = await weightedScore(otherUserRatings2, pCScore); // get weighter score\r\n            pcWScores.push({ weighted_scores: pcWScore });\r\n            \r\n            /* Push objects */\r\n            pCUserSimilarity.push({\r\n                id: subId,\r\n                user_name: name,\r\n                pearsonScore: pCScore,\r\n            }); \r\n        } \r\n    }\r\n\r\n    /* Sort similarity highest to lowest */\r\n    /* Euclidean */\r\n    eUserSimilarity.sort((a: { euclideanScore: any; }, b: { euclideanScore: any; }) =>\r\n    parseFloat(b.euclideanScore) - parseFloat(a.euclideanScore)\r\n    ); \r\n    // /* Pearson Correlation */\r\n    pCUserSimilarity.sort((a: { pearsonScore: any; }, b: { pearsonScore: any; }) =>\r\n    parseFloat(b.pearsonScore) - parseFloat(a.pearsonScore)\r\n    ); \r\n    \r\n    let eWCalc = await weightedCalculations(eWScores.map(x => x['weighted_scores']));\r\n    let pCWCalc = await weightedCalculations(pcWScores.map(y => y['weighted_scores']));\r\n\r\n    // res.json(JSON.stringify(await buildJson(user, eUserSimilarity, eWCalc, pCUserSimilarity, pCWCalc), null, 2));\r\n\r\n    let test = await getUser(id);\r\n    res.json(test)\r\n}\r\n\r\nexport default euclideanAPI;"]},"metadata":{},"sourceType":"module"}